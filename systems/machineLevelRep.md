# Machine-Level Representation of Programs:
- This document will delve into machine code and its human-readable representation, assembly code.
- Ù‘Why learn about assembly when compilers can do it all and nobody has to write assembly anymore? Understanding the assembly code generated by the compiler allows you to:
	+ Rewrite your high-level code for better compiler optimization.
	+ Better understand the runtime behavior of your code. This behavior might be hidden by the high-level language abstraction and is only visible in its machine-level representation. 
	+ Write more secure code because security vulnerabilities can be better understood through its machine-level representation.
- This document is not about writing assembly code but about reading and understanding assembly generated by compilers and trying to the understand its links to the original high-level C code. This is more about *reverse-engineering*, sorta!
- This document will also be about the ***x86-64*** processor. It's a complex beast but the focus will be on GCC and Unix (mainly Linux).
- A quick summary of what will be discussed in this document is as follows:
	- A tour of the relationship between C, assembly and machine code.
	- The representation and manipulation of data and implementation of control constructs such as `if` and and `while` statements.
	- The implementation of procedures details, such as how they maintain a runtime stack or store local variables or pass data to other processes, etc.
	- How data structures such as arrays and structures are implemented.
	- The reasons behind out of out-of-bounds memory references and how buffer overflow attacks and other vulnerabilities happen. 
	- How floating-point data and operations work at the machine level. 

## Program Encoding:
- We've covered what happens when a C program is compiled with the GCC compiler [here](computerSystems.md/#2-programs-are-translated-by-other-programs-into-different-forms).
- To better understand the relationship between C code and compiled assembly, we use the **`-Og`** option with GCC to produce machine code that is not optimized and close in structure to the original C code.

### Machine-Level Code:
- Two very important machine-level Programming abstractions are:
	1. The ISA (*instruction set architecture*) which defines the processor state, the format of the instructions and the effect these instructions have on the state. These instructions appear to execute in sequence but in effect the processor might execute them simultaneously while making sure they behave as if they execute in sequence.
	2. *Virtual memory* which gives the illusion the process has access to a very long array of bytes but that array is an abstraction of a combination of multiple hardware memories and operating system software.
- However, the machine code that you see in the form of assembly is not as abstracted as high-level C and doesn't hide many of the things that you are totally oblivious to when only coding in high-level languages. Examples of these things which have to do with the processor's state include:
	- The **program counter (PC)**: known as **`%rip`** in x86-64. It indicates the address of the next instruction to be executed. 
	- The integer **register file** contains 16 registers storing 64-bit values. These registers can hold addresses (C pointers) and integer data. They are used to keep track of critical parts of the program's state and hold temporary data such as local function data and data to be returned.
	- The condition code registers hold information about most recently executed logic or arithmetic instructions. These information are used for the control of data flow during loops and conditionals.
	- A group of vector registers used to hold one or more integer or floating-point values. 
- While your run-of-the-mill high-level language declare and allocate in memory objects of different data types, assembly only sees a large byte-addressable array. Aggregate data such as arrays and structures are collections of contiguous bytes and scalar data such as integers and floats are all the same. Assembly doesn't differentiate between signed and unsigned integers or between pointers and integers. 
- The program's memory contains:
	- The executable code of the program. 
	- Information required by the OS.
	- Run-time stack for managing procedure calls and returns.
	- Blocks of memory allocated by the user through the `malloc` function.
- Our assembly operates on the virtual memory which an abstraction that hides and simplifies the inner workings of hardware memory. The OS manages translating between virtual memory and the complexities of the metal.
- Machine instructions perform very basic actions such as adding two numbers stored in registers, moving data from memory to a register or branch to a new instruction address. The compiled code is a sequence of such instructions.

### Code Examples
```c
long mult2(long, long);

void multstore(long x, long y, long *dest){
    long t = mult2(x, y);
    *dest = t;
}
```
- To get the assembly output of the above C program (let's say it's in a pogram named `wawa.c`), we use the following command:
```sh
gcc -Og -S wawa.c
```
- In this command we instruct the gcc to output the files's assembly equivalent. **`-Og`** as know prevents optimization. The assembly output should looks as follows:

```assembly
multstore:
	pushq	%rbx
	movq	%rdx, %rbx
	call	mult2
	movq	%rax, (%rbx)
	popq	%rbx
	ret
```
- I tried this on OS X and got a different output that shares a lot with this one. I also tried on Ubuntu Linux and it was essentially the same as this one bar the directives that I have removed. 
- Each indented line in the assembly code represents a single machine instruction. Notice how all variable names and data types have been stripped away. 
- Using the following command, you can generate an object code from the C file:
```bash
gcc -Og -c wawa.c
```
- The generated object file `wawa.o` contains the machine code we saw earlier but it's in binary format consisting of the following 14-byte sequence:
```
53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
```
- We can use a *disassembler* to disassemble the object file `wawa.o` to get this binary format along with its assembly mnemonics. Linux favorite disassemble is **`objdump`** which we'd use with the option **`-d`** as follows:
```sh
objdump -d wawa.o
```
- `objdump` outputs the following:
```assembly
0000000000000000 <multstore>:
   0:	53                   	push   %rbx
   1:	48 89 d3             	mov    %rdx,%rbx
   4:	e8 00 00 00 00       	callq  9 <multstore+0x9>
   9:	48 89 03             	mov    %rax,(%rbx)
   c:	5b                   	pop    %rbx
   d:	c3   
```
- To the left are the 14 bytes we saw earlier in the `wawa.o` object file. and to the right are the instructions they correspond to in assembly. You can notice how binary instructions range between 1 and 5 bytes in length an that they hhave a slightly different format from the assembly generated by gcc such as that gcc's `pushq` is replaced by `push`.
- If we create a `main.c` file and populate it with a `main` function and a definition fo `mult2` function and compile it along with `wawa.c` and have everything linked together, and then disassembled we will obtain a file that contains something similar to the following code:
```assembly
000000000040054 <multstore>:
   400540:	53                   	push   %rbx
   400541:	48 89 d3             	mov    %rdx,%rbx
   400544:	e8 00 00 00 00       	callq  40058b <mult2>
   400549:	48 89 03             	mov    %rax,(%rbx)
   40054c:	5b                   	pop    %rbx
   40054d:	c3                   	retq
   40054e:	90                   	nop
   40054e:	90                   	nop
```
- This is similar to the the isolated object dump of `wawa.o`, but does also have some important differences:
	- Addresses on the left of each instruction in this program are different. They kinda look real as opposed to the earlier *placeholders*.
	- The address of the function to be called by `callq` instruction is filled up and `<multstore+0x9>` is replaced by `<mult2>`.
	- The final two instructions are just fillers to grow the code to be 16 bytes instead of just 14. This will allow for a better placement of the next block of code which is better for performance :confused:. (*You can say that walking down a stair with uniform-sized steps is better than if steps had different sizes*).
 
### Formatting:
- The following snippet is of the full assembly code generated by gcc:
```assembly
	.file	"lala.c"
	.text
	.globl	multstore
	.type	multstore, @function
multstore:
.LFB0:
	.cfi_startproc
	pushq	%rbx 
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	movq	%rdx, %rbx
	call	mult2@PLT
	movq	%rax, (%rbx)
	popq	%rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
.LFE0:
	.size	multstore, .-multstore
	.ident	"GCC: (Ubuntu 7.3.0-27ubuntu1~18.04) 7.3.0"
	.section	.note.GNU-stack,"",@progbits
```
- This code has a lot of information the programmer doesn't care about or need, but also lack a lot of information about how this code works or what it's doing!
- From now on we will ignore stuff we don't need to know such as directives which start with **`.`** such as `.size	multstore, .-multstore`. On the other hand comments will be added to lines corresponding to the C code as the following example shows for a single instruction (the comment follows the symbol `#`):
```assembly
movq	%rax, (%rbx) # Copy dest to %rbx
``` 
- Since we live in a Unix/Linux world, we use the ATT assembly format rather than Intel's format which is encountered in Micosofty stuff and Intel's documentation. It's a little different in that has a reversed order of operands to that ATT, doesn't use size indicators such as `q` at the end of `pushq`, etc.

## Data Formats:
- The following table shows the different x86-64 representations corresponding to C data types:

| C declarations | Intel data types | Assembly-code suffix | Size in bytes |
| --- | --- | --- | --- |
| <code>char</code> | Byte | <code>b</code> | 1 |
| <code>short</code> | Word | <code>w</code> | 2 |
| <code>int</code> | Double word | <code>l</code> | 4 |
| <code>long</code> | Quad word  | <code>q</code> | 8 |
| <code>char *</code> | Quad word | <code>q</code> | 8 |
| <code>float</code> | Single precision | <code>s</code> | 4 |
| <code>double</code> | Double precision | <code>l</code> | 8 |

- The first x86 processor used a 16-bit architecture, that's why 2 bytes are called a **word**, 32 bits are a **double word** and a 64-bit bit vector is called a **quad word**.
- Instructions can operate on words of different lengths, hence the different assembly suffixes such as **`b`**, **`q`**, and **`s`**.

## Accessing Information:
- x86-64 CPUs have 16 **general-purpose registers** which are used to store 64-bit values of integer and pointer data types. These registers names start with **`%r`** are shown in the following table:

| Functionality | 63-0 | 31-0 | 15-0 | 7-0 |
| --- | --- | --- | --- | --- |
| Return value | <code>%rax</code> | <code>%eax</code> | <code>%ax</code> | <code>%al</code> |
| Callee saved | <code>%rbx</code> | <code>%ebx</code> | <code>%bx</code> | <code>%bl</code> |
| 4th argument |<code>%rcx</code> | <code>%ecx</code> | <code>%cx</code> | <code>%cl</code> |
| 3rd argument |<code>%rdx</code> | <code>%edx</code> | <code>%dx</code> | <code>%dl</code> |
| 2nd argument |<code>%rsi</code> | <code>%esi</code> | <code>%si</code> | <code>%sil</code> |
| 1st argument |<code>%rdi</code> | <code>%edi</code> | <code>%di</code> | <code>%dil</code> |
| Callee saved |<code>%rbp</code> | <code>%ebp</code> | <code>%bp</code> | <code>%bpl</code> |
| Stack pointer |<code>%rsp</code> | <code>%esp</code> | <code>%sp</code> | <code>%spl</code> |
| 5th argument |<code>%r8</code> | <code>%r8d</code> | <code>%r8w</code> | <code>%r8b</code> |
| 6th argument argument |<code>%r9</code> | <code>%r9d</code> | <code>%r9w</code> | <code>%r9b</code> |
| Caller saved |<code>%r10</code> | <code>%r10d</code> | <code>%r10w</code> | <code>%r10b</code> |
| caller saved |<code>%r11</code> | <code>%r11d</code> | <code>%r11w</code> | <code>%r11b</code> |
| Callee saved |<code>%r12</code> | <code>%r12d</code> | <code>%r12w</code> | <code>%r12b</code> |
| Callee saved |<code>%r13</code> | <code>%rd13</code> | <code>%r13w</code> | <code>%r13b</code> | 
| Callee saved |<code>%r14</code> | <code>%rd14</code> | <code>%r14w</code> | <code>%r14b</code> |
| Callee saved |<code>%r15</code> | <code>%rd15</code> | <code>%r15w</code> | <code>%r15b</code> |

- The The table also shows the historical registers found in 32-bit and 16-bit older generations x86 processors. These older generation registers accommodating different architectures can still be used in x86-64 and their conventions show the evolution of x86 architecture. 
- The original x86 16-bit registers were were expanded with the IA32 to hold 32 bits and names were changed so **`%ax`** became **`%eax`** and **`%bp`** became **`%ebp`**, etc. With IA64, these registers started holding 64 bits of data and names like **`%ebp`** became **`%rbp`**. 8 new registers were added and you can refer to the table above on how they were named. 
- Instructions can use these registers to operate on different data sizes, so byte instructions operate on the least significant byte in the register, word operators can use use the least significant 16-bits, etc. 
- The table above also shows the functionality and purposes of these registers. The stack pointer **`%rsp`** is unique. It indicates the end of the run time stack of a program, whatever that means! Some instructions are specialized to read from and write to this register. The other registers are more flexible. Some of them have specialized instructions and some are used for managing the stack such as returning values from functions or passing arguments.. etc. We will see more about these!

### Operand Specifiers:
- Most instructions have one or more operands that specify the source values used in the operation and the destination location where to place the results. Source values can be constants or read from registers or memory. Results can be stored in registers or memory. 
- The following table shows the different forms operands can take:

| Type | Form | Operand value | Name |
| --- | --- | --- | --- |
| Immediate | *$Imm* | *Imm* | Immediate | 
| Register | *r<sub>a</sub>* | R[r<sub>a</sub>] | Register | 
| Memory | *Imm* | M[*Imm*] | Absolute | 
| Memory | *(r<sub>a</sub>)* | M[R[r<sub>a</sub>]] | Indirect | 
| Memory | *Imm(r<sub>b</sub>)* | M[*Imm* + R[r<sub>b</sub>]] | Base +  Displacement | 
| Memory | *(r<sub>b</sub>, r<sub>i</sub>)* | M[R[r<sub>b</sub>] + R[r<sub>i</sub>]] | Indexed | 
| Memory | *Imm(r<sub>b</sub>, r<sub>i</sub>)* | M[*Imm* + R[r<sub>b</sub>] + R[r<sub>i</sub>]] | Indexed | 
| Memory | *(,r<sub>i</sub>, s)* | M[R[r<sub>i</sub>] Â· *s*] | Scaled Indexed | 
| Memory | *Imm(,r<sub>i</sub>, s)* | M[*Imm* + R[r<sub>i</sub>] Â· *s*] | Scaled Indexed | 
| Memory | *(r<sub>b</sub>, r<sub>i</sub>, s)* | M[R[r<sub>b</sub>] + R[r<sub>i</sub>] Â· *s*] | Scaled Indexed | 
| Memory | *Imm(r<sub>b</sub>, r<sub>i</sub>, s)* | M[*Imm* + R[r<sub>b</sub>] + R[r<sub>i</sub>] | Scaled Indexed | 

- There are 3 types of operands:
	- *Immediate* is used for constant values. It uses **`$`** followed by standard C notation for integers as in **`$-14`** or **`0xFD2`**. Remember that different instructions allow for different ranges of values. 
	- *Register*
	- *Memory*

### Date Movement Instructions:
### Pushing and Popping Stack Data:
### 

## Arithmetic and Logical Operations:
## Control:
## Procedures:
## Array Allocation and Access:
## Heterogeneous Data Structures:
## Combining Control and Data Machine-Level Programs:
## Floating-Point Code:
















